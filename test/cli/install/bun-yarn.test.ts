import { file, spawn } from "bun";
import { afterAll, afterEach, beforeAll, beforeEach, expect, it } from "bun:test";
import { bunExe, bunEnv as env } from "harness";
import { access, mkdir, mkdtemp, readlink, realpath, rm, writeFile } from "fs/promises";
import { join, relative } from "path";
import { tmpdir } from "os";
import {
  dummyAfterAll,
  dummyAfterEach,
  dummyBeforeAll,
  dummyBeforeEach,
  dummyRegistry,
  package_dir,
  readdirSorted,
  requested,
  root_url,
  setHandler,
} from "./dummy.registry";

beforeAll(dummyBeforeAll);
afterAll(dummyAfterAll);

let add_dir: string;

beforeEach(async () => {
  add_dir = await mkdtemp(join(await realpath(tmpdir()), "bun-yarn.test"));
  await dummyBeforeEach();
});

afterEach(async () => {
  await rm(add_dir, { force: true, recursive: true });
  await dummyAfterEach();
});

async function command(...args: Array<string>) {
  const { stdout, stderr, exited } = spawn({
    cmd: [bunExe(), ...args],
    cwd: package_dir,
    stdout: null,
    stdin: "pipe",
    stderr: "pipe",
    env,
  });
  expect(stderr).toBeDefined();
  const err = await new Response(stderr).text();
  expect(stdout).toBeDefined();
  const out = await new Response(stdout).text();
  return { err, out };
}

const getPackageJSONContents = () => file(join(package_dir, "package.json")).text();
const getYarnLockContents = () => file(join(package_dir, "yarn.lock")).text().then(s => s.replaceAll(root_url, "localhost"));
const makeBasicPackageJSON = (dependencies = {}, devDependencies = {}) => writeFile(join(package_dir, "package.json"), JSON.stringify({ name: "foo", version: "0.0.0", dependencies, devDependencies }));

// it("should wrap package title names that begin with true or false in quotes.", async () => {
//   for (const [pkg_name, pkg_ver] of [
//     ["true", "0.0.4"],
//     ["false", "0.0.4"],
//     ["falsetto", "0.2.5"],
//     ["true-case-path", "2.2.1"],
//   ]) {
//     const urls: string[] = [];
//     setHandler(dummyRegistry(urls, { [pkg_ver]: {} }));
//     await makeBasicPackageJSON();
//     const { err, out } = await command("install", pkg_name, "-y");
//     expect(err).toContain("Saved yarn.lock");
//     expect(out).toContain(`installed ${pkg_name}@${pkg_ver}`);
//     expect(await getYarnLockContents()).toMatchSnapshot();
//   }
// });

const yarn_lock_emoji_turkey = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


emoji-turkey@^1.2.0:
  version "1.2.1"
  resolved "https://registry.npmjs.org/emoji-turkey/-/emoji-turkey-1.2.1.tgz"
  integrity sha512-aWuEIF2O8FyOHtL/on255zwJDqy4htyYO+J3iz7ic+1SyhX/qAVpQrl0O6wzpzYEBSifgXetp2QFen7GPU7Hlw==`

it("should grab the file specified in the yarn.lock file when no other lockfile is present", async () => {
	const urls: string[] = [];
  setHandler(dummyRegistry(urls, { "1.2.0": {}, "1.2.1": {}, "1.3.0": {} }));
  await makeBasicPackageJSON({ "emoji-turkey": "^1.2.0" }); // latest version is 1.3.0, but we are asking for 1.2.1 via the yarn.lock file
	await writeFile(join(package_dir, "yarn.lock"), yarn_lock_emoji_turkey);
  const { err, out } = await command("install", "-y");
  expect(err).toContain("Saved yarn.lock");
  expect(out).toContain(`emoji-turkey@1.2.1`);
  // expect(await getYarnLockContents()).toMatchSnapshot();
  // expect(await getPackageJSONContents()).toMatchSnapshot();
})
