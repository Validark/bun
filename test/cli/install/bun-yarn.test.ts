import { file, spawn } from "bun";
import { afterAll, afterEach, beforeAll, beforeEach, expect, it } from "bun:test";
import { bunExe, bunEnv as env } from "harness";
import { access, mkdir, mkdtemp, open, readdir, readlink, realpath, rm, writeFile } from "fs/promises";
import { join, resolve } from "path";
import { tmpdir } from "os";
import {
  dummyAfterAll,
  dummyAfterEach,
  dummyBeforeAll,
  dummyBeforeEach,
  dummyRegistry,
  package_dir,
  readdirSorted,
  requested,
  root_url,
  setHandler,
  external_command,
  command,
  getPackageJSONContents,
  getYarnLockContents,
  makeBasicPackageJSON,
} from "./dummy.registry";

beforeAll(dummyBeforeAll);
afterAll(dummyAfterAll);

let add_dir: string;

beforeEach(async () => {
  add_dir = await mkdtemp(join(await realpath(tmpdir()), "bun-yarn.test"));
  await dummyBeforeEach();
});

afterEach(async () => {
  await rm(add_dir, { force: true, recursive: true });
  await dummyAfterEach();
});

it("should wrap package title names that begin with true or false in quotes.", async () => {
  for (const [pkg_name, pkg_ver] of [
    ["true", "0.0.4"],
    ["false", "0.0.4"],
    ["falsetto", "0.2.5"],
    ["true-case-path", "2.2.1"],
  ]) {
    const urls: string[] = [];
    setHandler(dummyRegistry(urls, { [pkg_ver]: {} }));
    await makeBasicPackageJSON();
    const { err, out, exited } = await command("install", pkg_name, "-y");
    expect(await exited).toBe(0);
    expect(err).toContain("Saved yarn.lock");
    expect(out).toContain(`installed ${pkg_name}@${pkg_ver}`);
    expect(await getYarnLockContents()).toMatchSnapshot();
  }
});

const yarn_lock_emoji_turkey = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


emoji-turkey@^1.2.0:
  version "1.2.1"
  resolved "https://registry.npmjs.org/emoji-turkey/-/emoji-turkey-1.2.1.tgz"
  integrity sha512-aWuEIF2O8FyOHtL/on255zwJDqy4htyYO+J3iz7ic+1SyhX/qAVpQrl0O6wzpzYEBSifgXetp2QFen7GPU7Hlw==`

it("should grab the file specified in the yarn.lock file when no other lockfile is present", async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, { "1.2.0": {}, "1.2.1": {}, "1.3.0": {} }));
  await makeBasicPackageJSON({ "emoji-turkey": "^1.2.0" }); // latest version is 1.3.0, but we are asking for 1.2.1 via the yarn.lock file
  await writeFile(join(package_dir, "yarn.lock"), yarn_lock_emoji_turkey);
  const { err, out, exited } = await command("install", "-y");
  expect(await exited).toBe(0);
  expect(err).toContain("Saved yarn.lock");
  expect(out).toContain(`emoji-turkey@1.2.1`);
  expect(await getYarnLockContents()).toMatchSnapshot();
  expect(await getPackageJSONContents()).toMatchSnapshot();
})

const yarn_lock_test_pkg_with_prerelease =
`# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


test_pkg_with_prerelease@^0.0.0-massively-long-prerelease-tag:
  version "0.0.0-massively-long-prerelease-tag"
  resolved "https://registry.yarnpkg.com/test_pkg_with_prerelease/-/test_pkg_with_prerelease-0.0.0-massively-long-prerelease-tag.tgz#1c35e8548bda8b57df0fa3a8e2d19adc2df871b7"
  integrity sha512-XBCx9Ce+vAiBVsxLC6jAU7PPJuysLNZZhR+rT17IvVvGVm2MVsAffu0fmJwB1e7XDQ/9k2NM6ugFYpHPbzmuCA==
`;

// We test this separately because there is extra logic for prerelease version strings that are not inlineable by `String`
// We do a little space optimization where the prerelease version literal can point inside the filename string.
it("should work for files with long prerelease versions with version numbers in the filename", async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, { "0.0.0-massively-long-prerelease-tag": {} }));
  await makeBasicPackageJSON({ "test_pkg_with_prerelease": "^0.0.0-massively-long-prerelease-tag" });
  await writeFile(join(package_dir, "yarn.lock"), yarn_lock_test_pkg_with_prerelease);
  const { err, out, exited } = await command("install", "-y");
  expect(await exited).toBe(0);
  expect(err).toContain("Saved yarn.lock");
  expect(out).toContain(`test_pkg_with_prerelease@0.0.0-massively-long-prerelease-tag`);
  expect(await getYarnLockContents()).toMatchSnapshot();
  expect(await getPackageJSONContents()).toMatchSnapshot();
})

const yarn_lock_test_pkg_with_prerelease2 =
  `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1
# bun ./bun.lockb --hash: C4A807CA0191E97A-f12382d9a045f641-258DFF03787839E8-99738125a32e4587


"test_pkg_with_prerelease_2@https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz":
  version "0.0.1-massively-long-prerelease-tag"
  resolved "https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz"
`;

it("should work for files with long prerelease versions with no version number in the filename", async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, { "test_pkg_with_prerelease_2.tgz": {} }));
  await makeBasicPackageJSON({ "test_pkg_with_prerelease_2": "https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz" });
  await writeFile(join(package_dir, "yarn.lock"), yarn_lock_test_pkg_with_prerelease2);
  const { err, out, exited } = await command("install", "-y");
  expect(await exited).toBe(0);
  expect(err).toContain("Saved yarn.lock");
  expect(out).toContain(`test_pkg_with_prerelease_2@https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz`);
  expect(await getYarnLockContents()).toMatchSnapshot();
  expect(await getPackageJSONContents()).toMatchSnapshot();
})


it("should work for files with long prerelease versions with no version number in the filename not in a lockfile", async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, { "https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz": {} }));
  const { err, out, exited } = await command("install", "https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz", "-y");
  expect(await exited).toBe(0);
  expect(err).toContain("Saved yarn.lock");
  expect(out).toContain(`test_pkg_with_prerelease_2@https://github.com/Validark/Validark/raw/master/test_pkg_with_prerelease_2_.tgz`);
  expect(await getYarnLockContents()).toMatchSnapshot();
  expect(await getPackageJSONContents()).toMatchSnapshot();
})

const yarn_lock_files_from_internet = new Array<[org: string, repo: string]>();

for (const org of await readdir("./resources/yarn")) {
  for (const repo of await readdir(`./resources/yarn/${org}`)) {
    yarn_lock_files_from_internet.push([org, repo]);
  }
}

it(`should properly parse all ${yarn_lock_files_from_internet.length} yarn.lock files harvested from GitHub`, async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, {}));
  await makeBasicPackageJSON();
  for (const [org, repo] of yarn_lock_files_from_internet) {
    const yarn_lock = await file(`./resources/yarn/${org}/${repo}/yarn.lock`).text();
    await writeFile(join(package_dir, "yarn.lock"), yarn_lock);
    const { exited } = await command("install");
    expect(await exited).toBe(0);
  }
})

// Very, very, very slow! It's somewhat like a fuzzer
/*
it(`should not segfault for partial yarn lockfiles`, async () => {
  for (const org of files) {
    const urls: string[] = [];
    setHandler(dummyRegistry(urls, {}));
    await makeBasicPackageJSON();
    for (const repo of await readdir(`./resources/yarn/${org}`)) {
      const yarn_lock = await file(`./resources/yarn/${org}/${repo}/yarn.lock`).text();
      for (let i = 0; ++i <= yarn_lock.length; ) {
        await writeFile(join(package_dir, "yarn.lock"), yarn_lock.slice(0, i));
        const { exited } = await command("i");
        const exit_code = await exited;
        expect(exit_code === 0 || exit_code === 1).toBe(true);
      }
    }
  }
})
*/

const test_yarn_source = `
"@angular/build-tooling@https://github.com/angular/dev-infra-private-build-tooling-builds.git#414801b1253d48294087fed2bd4d7b07634c2b40", @angular/build-tooling@x:
  name x
  version "0.0.0-7b31625b050e81dcdb575c22f4ed3991922b5bbc"
  uid "414801b1253d48294087fed2bd4d7b07634c2b40"
  resolved "https://github.com/angular/dev-infra-private-build-tooling-builds.git#414801b1253d48294087fed2bd4d7b07634c2b40"
  integrity sha512-ApxoY5lTj1S0QFLdq5ZdTfdkIds1m3tma9EJOZpNVHRU9eCj2D/5+VFb5tlWsv9NHQ2S0XXkJjauFOAdfzT8uw==
  registry nom-nom-nom!
  dependencies:
    "@angular/core" "^13.0.0 || ^14.0.0-0"
    truth x
  optionalDependencies:
    "true" v1.2.3
    yargs "^17.0.0"
`

const valid_start_and_end_states = [..."0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111110000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110001111111111000000000000001111111111111111111111111111111111111111111111111111111110011111111110011111111111111111111111111111111111000000011111111111111111100"].map(c => +c);

it(`should allow termination at valid locations`, async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, {}));
  await makeBasicPackageJSON();
  const { length } = test_yarn_source;
  const arr = new Array(length);

  for (let i = 0; i < length; i++) {
    const slice = test_yarn_source.slice(0, i + 1);
    await writeFile(join(package_dir, "yarn.lock"), slice);
    const { exited } = await command("install");
    const x = await exited;
    arr[i] = x;
  }

  expect(arr).toEqual(valid_start_and_end_states);

  // For manual auditing:

  // const width = 80;
  // for (let i = 0; i < test_yarn_source.length; i += width) {
  //   console.log(test_yarn_source.slice(i, i + width).replaceAll('\n', '+'));
  //   console.log(arr.slice(i, i + width).join(""));
  //   console.log()
  // }
  // console.log(arr.join(""))
})

it(`should properly print local tarballs in yarn.lock`, async () => {
  const urls: string[] = [];
  setHandler(dummyRegistry(urls, {}));
  await makeBasicPackageJSON();
  await command("add", resolve("./resources/true-0.0.4.tgz"), "-y");
  expect(await getYarnLockContents()).toMatchSnapshot();
})
